//: Playground - noun: a place where people can play

/*
 
 Swift 的类型分为 值类型 和 引用类型 两种
 值类型在传递和赋值时将进行复制，而引用类型则只会使用引用对象的一个“指向”
 
 Swift 中的 struct 和 enum 定义类型的类型是值类型
 使用 class 定义的为引用类型。
 
 很有意思的是，Swift 中所有的内建类型都是值类型，不仅包括了传统意义像Int Bool这些
 甚至连 String Array 以及 Dictionary 都是值类型
 
 这在程序设计上绝对算得上是一个震撼的改动，在现在流行的编程语言中，像数组和字典这样的类型，几乎轻易死额的都是引用类型。

 */


/*
 使用值类型的好处:
 
 相较于传统的引用类型来说，一个很显而易见的优势就是减少了堆上内存分类和回收的次数
 首先知道
 Swift 的值类型，特别是数组和字典这样的容器，在内存管理上经过了精心的设计
 值类型的一个特点就是在传递和赋值是进行复制，每次复制肯定会产生额外的开销
 但是 Swift 中这个消耗被控制在了最小氛围内，在没有必要复制的时候，值类型的复制都是不会发生的。
 
 也就是说，简单的赋值，参数的传递等等普通操作，虽然可能用不同的名字来回设置和传递至类型
 但是内存上他们都是同一块内容
 */

//Example:
func test(_ arr: [Int]) {
    for i in arr {
        print(i)
    }
}

var a = [1,2,3]
var b = a
let c = b
test(a)
/*
 这样折腾一圈下来，其实只在第一句 a 初始化赋值时发生了内存分配
 而之后的 b,c 甚至传递到 test 方法内的 arr,
 和最开始的 a 在物理内存上都是同一个东西
 
 而且这个 a 还只在栈空间上，于是这个过程对于数组来说，只发生了指针移动
 而完全没有堆内存的分配和释放的问题，这样的运行效率可以说极高
 */


/*
 值类型被复制的时机是值类型的内容发生改变时，比如下面在 b 中加入了一个数
 此时值复制就是必须的:
 */
var a1 = [1,2,3]
var b1 = a1
b1.append(5)

// 值类型在复制时，会将存储在其中的值类型一并进行复制，而对于其中的引用类型的话，则只复制一份引用
// 这是合理的行为，因为不会希望引用类型莫名其妙的引用到了我们设定以外其他对象:

class MyObject {
    var num = 0
}

var myObject = MyObject()
var a2 = [MyObject]()
var b2 = a2

b2.append(myObject)

myObject.num = 100
print(b2[0].num)//100
print(b2[1].num)//100

// myObject 的改动同时影响了 b[0] 和 b[1]

/*
 虽然将数组和字典设计为值类型最大的考虑是为了线程安全
 但这样的设计在存储的元素或条目数量较少时，给我们带来了另一个优点，就是很高效了
 因为 一旦赋值就不太会变化 这种使用场景在 Cocoa 框架中占有绝大多数的，这有效减少了内存的分配和回收
 
 但是在少数情况下，显然也可能会在数组或者字典中存储非常多的东西
 并且还要对其中的内容进行添加或者删除。
 
 在这时， Swift 内建的值类型的容器类型在每次操作时都需要复制一遍
 即使是存储的都是引用类型，在复制是还是需要存储大量的引用，这个开销就变得不容忽视了。
 
 还好有 Cocoa 中的引用类型的容器类来对应这种情况
 那就是 NSMutableArray 和 NSMutableDictionary
 */

/*
 在使用数组和字典时的最佳时实践应该是
 按照具体的数据规模和操作特点来决定到时是使用值类型的容器还是引用类型的容器:
 
 在需要处理大量数据并且频繁操作(增减)其中元素时，选择 NSMutableArray 和 NSMutableDictionary会更好
 而对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary.
 */












