
/*:
 # 术语介绍
 */

/*:
 ## 值(Value):
 
 值是不变的，永久的，他从不会改变。
 比如`1，true、[1,2,3]`都是值
 这些 _字面量(Literal)_ 的例子，值也可以是运行时生成的。
 当计算5的平方时，得到的数字也是一个值。
 */

/*:
 ## 值类型(value type):
 
 _结构体(struct)_ 和 _枚举(enum)_ 是 _值类型(value type)_
 当把一个结构体变量赋值给另一个，那么这两个变量将会包含同样的值。
 可以将它理解为内容被复制了一遍，但是更精确地描述的话，是被赋值的变量与另外的那个变量包含了同样的值。
 */


/*:
 我们通过值类型是否执行 _深复制_ 来对他们分类
 判断他们是否具有 _值语义_
 这种复制可能是在赋值新变量时就发生的，也可能会延迟到变量内容发生变更的时候再发生
 */

/*:
 # 高阶函数(higher-order function)
 在 Swift 中，函数也是值。
 可以将一个函数赋值给一个变量，也可以创建一个包含函数的数组
 或者调用变量所持有的函数。
 如果一个函数接受别的函数作为参数(比如 map 函数接受一个转换函数，并将其应用到数组中的所有元素上)
 或者一个函数的返回值是函数，那么这样的函数就叫做 高阶函数.
 */

/*:
 # 闭包(closure)
 函数不需要被声明在最高层级 - 可以在一个函数内部声明另一个函数
 也可以在一个 do 作用域或者其他作用域中声明函数
 
 如果一个函数被定义在外层作用域中，但是被传递出这个作用域
 (比如把这个函数被作为其他函数的返回值返回时)
 它将能够“捕获”局部变量
 这些局部变量将存在与函数中，不会随着局部作用域的结束而消亡
 函数也将持有他们的状态
 这种行为的变量被称为“闭合变量”，我们把这样的函数叫做闭包(closure).
 
 函数可以通过`func`关键字来定义，也可以通过 {} 这样的简短的 _闭包表达式(closure expression)_来定义
 有时候我们只把通过闭包表达式创建的函数叫做“闭包”
 不过不要让这种叫法蒙蔽了双眼
 实际上使用 `func` 关键字定义的函数，如果包含了外部的变量，那么他也是一个闭包。
 
 ## 函数是引用类型
 也就是说，将一个捕获了状态的函数赋值给另一个变量，并不会导致这些状态被赋值
 和对象引用类似，这些状态会被共享
 换句话说，当两个闭包持有相同的局部变量时，他们是共享这个变量以及他的状态的
 */

/*:
 # 函数(Method)
 定义在类或者协议中的函数就是方法，他们有一个隐式的`self`参数
 如果一个函数不是接受多个参数，而是只接受部分参数
 然后返回一个接收其余参数的函数的话，那么这个函数就是一个 _柯里化函数(curried function)_
 有时候会把这些不是方法的函数叫做 _自有函数(free function)_
 */

/*:
 # 静态派发(statically dispatched)
 自由函数和那些结构体上调用的方法是 静态派发
 对于这些函数的调用，在编译的时候就已经确定了。
 对于静态派发的调用，编译器可能能够内联这些函数
 也就说，全完不去做函数调用，而是将函数调用替换为函数中需要执行的代码。
 优化器还能够帮助丢去或者简化那些在编译时就能确定不会被实际执行的代码。
 */

/*:
 # 动态派发(dynamically dispatched)
 类或者协议上的方法可能是动态派发的。
 编译器在编译时不需要知道那个函数将被调用
 在 Swift 中，这种动态特性要么由 vtable 来完成
 要么通过 selector 和 objc_msgSend 来完成
 前者的处理方式和 Java 或是 C++ 中类似
 而后者只针对 `@objc` 的类和协议上的方法。
 */

/*:
 子类型和方法重写(overriding)是实现多态特性的手段
 也就说，根据类型的不同，同样的方法会呈现出不同的行为
 
 另一种方式是函数重载(overloading)
 它是指为不同的类型多次写同一个函数的行为(不能把重写和重载弄混了，是完全不同的)
 
 实现多态的第三种方法是通过泛型
 也就是一次性编写能够接受任意类型的函数或者方法
 不过这些方法的实现会各有不同
 
 与方法重写不同的是，泛型中的方法在编译期间就是静态已知的。
 */
