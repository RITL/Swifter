//: Playground - noun: a place where people can play

import UIKit

// final 关键字可以用在class func 或者 var 前面进行修饰，表示不允许对该内容进行集成或者重写操作。
// 这个关键字的作用与 C# 中的sealed相同，而sealed其实在C#算是一个饱受争议的关键字。

//带着“这不是一个可以滥用的特性”的观点，看一下Swift的时候可能会在什么情况下使用final



//#权限控制

// 在一段代码加上final就意味着编译器向你做出保证，这段代码不会再被修改；
// 同时，也意味着你认为这段代码已经完备并且没有再被进行继承或重写的必要，因为这往往会是一个需要深思熟虑的决定。
// 在Cocoa开发中app开发是一块很大的内容，对于大多数我们自己完成的面向app开发代码，其实不太会提供给别人使用，这种情况下即使是将所有自己写的代码标记为final都是一件无可厚非的事情(不鼓励)
// 因为在需要的任何时候都可以讲这个关键字去掉以恢复其可继承性。
// 而在开发给其他开发者使用的库时，就必须更深入的思考各种使用场景和需求了。

//# 一般来说，不希望被继承或者重写会有这几种:

// 1.类或者方法的功能确实已经完备

// 对于很多辅助性质的工具类或者方法，可能会考虑加上final。
// 这样的类有一个比较大的特定点，是很可能只包含类方法而没有实例方法。
// 比如很难想到一种情况需要继承或重写一个负责计算一段字符串的MD5或者AES加密解密的工具类。
// 这种工具类和方法的算法是经过完备验证和固定的，使用者只需要调用，而相对来说不可能有继承和重写的要求。

// 这种情况很多时候遵循的是以往经验和主观判断，而单个的开发者的判断其实往往并不可靠。
// 遇到希望把某个自己开发的类或者方法标为final的时候，去找几个富有经验的开发者，问问他们的意见或者看法，应该是一个比较靠谱的做法。



//#子类继承和修改是一件危险的事情

// 在子类继承或者重写某些方法后可能做一些破坏性的事情，导致父类或者父类部分也无法正常工作的情况。

//Example:
// 在某个公司管理的系统中我们对员工按照一定规则进行编号，这样通过编号我们能迅速的找到任一员工。
// 而假如我们在子类中重写了这个编号方法，很有可能导致基类中的依赖员工编号的方法失效。
// 在这类情况下，将编号方法标记为final以确保稳定，可能是一种更好的做法。



//#为了父类中某些代码一定会被执行

// 有时候父类中有一些关键代码是被继承重写后必须执行的(比如状态配置，认证等等),否则将导致运行时候的而错误。
// 而在一般的方法中，如果子类重写了父类的方法，是没有办法强制子类方法一定去调用相同的父类方法的。

// 在ObjC的时候可以通过制定 __attribute__((objc_requires_super))这样的还需经来让编译器在子类没有调用父类方法时抛出警告。
// 在Swift中，对原来的很多 attribute的支持现在还缺失中，为了达到类似的目的，可以使用一个final的方法，在其中进行一些必要的配置，然后再调用某个需要子类实现的方法，以确保正常运行

//Example:
class Parent {
    
    final func method() {
        print("开始配置")
        // ..必要的代码
        methodImp()
        
        // ..必要的代码
        print("结束配置")
    }
    
    func methodImp() {
        fatalError("子类必须实现这个方法！")
    }
}

class Child: Parent {
    override func methodImp() {
        //子类的业务逻辑
    }
}

// 这样，无论如何我们如何使用method,都可以保证需要的代码一定被运行过，而同时又给了子类继承和重写自定义具体实现的机会



//# 性能考虑

// 使用final的另一个重要理由是可能带来性能改善。
// 因为编译器能够从 final 中获取额外的信息，因此可以对类或者方法调用进行额外的优化处理。
// 但是这个优势在实际表现中可能带来的好处其实就算与ObjC 的动态派发相比也十分有限，因此在项目还有其他方面可以优化（一般来说会是算法或者图形相关的内容导致性能瓶颈）的情况下，并不建议使用将类或者方法转为final 的方式来追求性能提升。
